---
title: "Methods 4 -- Portfolio Assignment 2"
output: html_notebook
editor_options: 
  chunk_output_type: inline
  markdown: 
    wrap: 72
---

-   *Type:* Group assignment
-   *Due:* 3 April 2022, 23:59

Hello CogSci's :)

In this portfolio, you are asked to do four tasks:

\- Make a DAG for something

\- Simulate data that fits the DAG

\- Use linear models to confirm that the DAG fits the data

\- Mess it up.

Each of the four tasks have some sub-steps.\
Report briefly what you find, for example in a markdown document, for
example called report.md so that the poor TA can easily get an overview
before looking in your code :)

Then you can also make a (brief!) explanation of the phenomenon you are
DAGGIN, simulating and modelling.

Looking forward !

## Task 1: The DAG

\- **Come up with an** incredibly interesting and scientifically
important made-up **example** for a phenomenon to investigate. Decide on
two variables (an outcome and a predictor) that you would like to
investigate the relation between. If in doubt, you **can be inspired by
Peter's amazing example** on the next page.

In our example, we wish to investigate the effect of corona fear (CF) on
the variable Infected (a binary variable taking either the value 0 or
1).

Predictor: corona fear (continuous variable) Outcome variable: infection
(0/1)

Sanitising: continuous variable FM variable: do you wear face mask
according to the national guidelines? (binary variable; 0/1) Germ level:
continuous

\- **Make a DAG** for the phenomenon. Make it medium complicated: that
means, make sure there are some different kinds of relations (see next
step). Change it if you don't get anything interesting for the next
steps.\
**Draw it** somehow (on paper, in R, laser engraved in diamond).\
**Code it** in dagitty (this is a nice tool:
<http://dagitty.net/dags.html> )

```{r}
pacman::p_load(usethis,dplyr, tidyverse, ggplot2, rstan, dagitty,ggdag)
library(rethinking)

#DAG corona
dag_corona<- dagitty( "dag {
    corona_fear -> sanitizing
    sanitizing-> germ_level
    face_mask -> germ_level
    corona_fear -> face_mask
    germ_level -> positive_test
}")


coordinates(dag_corona) <- list( x=c(Corona_Fear =0,Face_Mask =-1, Sanitizing =0, Germ_Level=-1, Posive_Test= -1) , y=c(Corona_Fear =0,Face_Mask =0, Sanitizing = 1, Germ_Level=1, Posive_Test=2) )


drawdag(dag_corona)

#more beautiful plot
#ggdag(dag_corona, layout="nicely")+theme_dag_blank()  # another layout
#smoking_ca_dag <- dagify(cardiacarrest ~ cholesterol,
#       cholesterol ~ smoking + weight,
#       smoking ~ unhealthy,
#       weight ~ unhealthy,
#       labels = c("cardiacarrest" = "Cardiac\n Arrest", 
#                  "smoking" = "Smoking",
#                  "cholesterol" = "Cholesterol",
#                  "unhealthy" = "Unhealthy\n Lifestyle",
#                  "weight" = "Weight"),
#       latent = "unhealthy",
#       exposure = "smoking",
#       outcome = "cardiacarrest")

#ggdag(smoking_ca_dag, text = FALSE, use_labels = "label")
```

\- Find **elemental forms of variable relations** in the DAG (i.e.,
forks, pipes, colliders, and their descendants).

Pipe

(FM -\> GERM -\> INFECTED)

(Cf --\> FM --\> GERM)

(CF -\> S -\> GERM)

(S --\> GERM --\> INFECTED)

Fork

(S \<- CF -\> FM)

Collider

(S -\> GERM \<- FM)

*OBS: ADD DESCRIPTION OF WHY WE BELIEVE THE RELATIONS ABOVE EXIST*.

\- Find out **what variables to include (and not include)** in a
multiple linear regression to avoid 'back door' (AKA non-causal) paths.
Do this first with your eyes and your mind. Then you can use dagitty's
function `adjustmentSets()`.

```{r}
# Shutting the backdoor - analyzing the graph to block the backdoor
adjustmentSets(dag_corona,exposure="corona_fear", outcome="positive_test")
```

*OBS: nothing here = No backdoors to shut (no confounding paths between Corona Fear and Infected)*

Chris: our input is CF (predictor, our intervention), our outcome is (infected). We don't have any backdoor paths, all paths are causal. If FM was a collider, it would be a common cause/confound that we would have to account for (hold constant) to close the backdown. We could aadd something that affects both FM and Germ_lvl. To have the total causal effect, we only need CF and Inf in out model (if we include FM and S, the coefficient for CF would just return the prior. Tge estimate for htis coefficient would be its own prior).

*You can ask your computer to reproduce this analysis, to analyze the graph and find the necessary variables to control for in order to block the backdoor. The dagitty R package provides adjustmentSets for this purpose*

In order to shut the backdoor. 
Here’s the recipe:
(1) List all of the paths connecting X (the potential cause of interest) and Y (the out- come).
(2) Classify each path by whether it is open or closed. A path is open unless it contains a collider.
(3) Classify each path by whether it is a backdoor path. A backdoor path has an arrow entering X.
(4) If there are any backdoor paths that are also open, decide which variable(s) to con- dition on to close it.
Let’s consider some examples.

\- Find out which **conditional independencies** the DAG implies. First
with the mind, then with daggity's function
`impliedConditionalIndependencies()`.

First, we find out which conditional independencies the DAG implies.

Pipe

(FM -\> GERM -\> INFECTED)

(Cf --\> FM --\> GERM)

(CF -\> S -\> GERM)

(S --\> GERM --\> INFECTED)

Fork

(S \<- CF -\> FM)

Collider

(S -\> GERM \<- FM)

```{r}
# Deriving our DAG’s conditional independencies
impliedConditionalIndependencies(dag_corona)
```

test crn\_ *\|\|* grm\_ \| fc_m, sntz *CF and G are independent of each
other if we stratify by both FM and SNTZ)*

    crn_ _||_ pst_ | grm_
    *If we stratify by G, there is no association between CF and Infection*

    crn_ _||_ pst_ | fc_m, sntz
    *OBS*

    fc_m _||_ pst_ | grm_
    *OBS*

    fc_m _||_ sntz | crn_
    *OBS*

    pst_ _||_ sntz | grm_
    *OBS*

OBS: WE NEED TO EXPLAIN HERE. Chris said the following in the lecture of
week 5: "there are a lot of implications of a DAG. There are different
ways to test its implication. Use \*dagitty\* to get a list of testable
implications (and go through this list one by one. If one of them is not
fulfilled, you can falsify your DAG - but you can't prove; you can only
say \*"This DAG is compatible with the data - there may be other
DAGs"\*.

##########################################################################################
##########################################################################################

p(FM)= S(CF)

CF is a continuum: as the fear increases, the probability of putting on mask increases. HOW do we simulate it? We can sim fear as normally distributed(0,1) which would give us a Gaussian. Then u say that whether a person puts on mask or not (FM) is rbern (1, sCP)). 

P(FM) = 1/1+exp(CP). That you use!!!

s(P

Sigmoid transformation (from min if to if), but prob can only be from 0 to 1. 

sCF (sigmoid transformation )

GL ~ rnorm(mu, sigma)

mu = b0+b1x1+b2x2

continuous –> bernomial (you translate to probability)

##########################################################################################
##########################################################################################


\- Find the full list of **Markov equivalent** DAGS. Use daggity's
function `equivalentGraphs()`.

The equivalentGraphs() function outputs a set of DAGs with the same
conditional independencies is known as a Markov equivalence set.

The list outputted allow show us 3 DAGS that would have the exact same
conditional independencies as our dag_corona has.

```{r}
equivalentDAGs(dag_corona)
```

Chris: We will get back the prior if we try to predict one thing from the other

## Task 2: The data

\- **Simulate some data that fits the DAG.** There are many ways to do
this. A simple way is just to sample one variable from a normal
distribution which has another variable as mean. McElreath does this in
the book a few times, and you can use this as inspiration.


*Corona Fear*
Normal

*Face Mask*
Binomial

*Sanitizing*
Poisson 

*Germ Level*
Normal

*Infected*
Binomial

```{r}
#simulating variables:
corona_fear <- rbeta(1000, 2, 5)#we assume skewedness (more people are not affraid, less people are super affraid)

#runif(1000, min= 0, max=100) #corona fear on a scale from 0 -100 (0= not being scared & 100= being scared)

facemask <- rbern(1000, 1/(1+exp(corona_fear))) #rbern(n, prob) # prob = A vector of likelihood of FM given CF.

sanitizing <- exp(corona_fear)

germ_level <-  rnorm(1000, mean=3500 , sd= 1000)
  
infected <-  rbinom(1000, size= 1, prob= 0.3) #probability??? # (OBS)

# creating df
df <- tibble(germ_level, sanitizing, infected, face_mask, corona_fear) 


```

```{r test chunk}

# Come up with a ground true 

# Simulating variables:
corona_fear <- rbeta(1000, 2, 5)#we assume skewedness (more people are not affraid, less people are super affraid)
hist(corona_fear)
mean(corona_fear)

# Runif(1000, min= 0, max=100) #corona fear on a scale from 0 -100 (0= not being scared & 100= being scared)

#face_mask <-  rbinom(1000, size= 1, prob= 0.5) # 1000 = antal observations, 1 = antal trials per observation, 0.5 = euqal probability for 0 and 1 at each trial

facemask <- rbern(1000, 1/(1+exp(corona_fear))) #rbern(n, prob) # prob = A vector of likelihood of FM given CF.

lambda_alpha ~ rexp(1)
lambda_cf <- lambda_alpha + (.5*corona_fear)*corona_fear

sanitizing <- dpois(1000, lambda_cf)  # Sanitizing on a count scale. lambda = average number of events per interval
hist(sanitizing)

# Hvordan gør vi den her afhængig af corona fear
germ_level <-  rnorm(1000, mean=3500 , sd= 1000)
  
infected <-  rbinom(1000, size= 1, prob= 0.3) #probability??? # (OBS)

# creating df
df <- tibble(germ_level, sanitizing, infected, face_mask, corona_fear)
```
Sanitize as exponentially related to corona fear

200 is max count sanitise a day!

sanitise = b * a^x, hvor a > 0 

sanitise_count = ax+bx^2 

x = CF

a = ?

b = ?



*Standardizing variables*

```{r}

df <- df %>% 
  mutate(germ_std=scale(germ_level),sanitizing_std= scale(sanitizing),  infected_std=scale(infected),face_mask_std=scale(face_mask ), corona_fear_std= scale(corona_fear))

```


## Task 3: Statistics

\- Run **multiple linear regression**s to **test the conditional
independencies** **implied by your DAG**. Make sure to avoid backdoor
paths. See that the linear model shows the conditional independencies
implied by your DAG, implying that the data and the DAG are compatible
(if the linear model doesn't show the conditional independencies implied
by the DAG, the data and the DAG doesn't fit).






### Testing the conditional independencies
```{r}
######### MODEL 1 ################
# crn_ _||_ grm_ | fc_m, sntz
model1 <- quap(
    alist(
        infected_std ~ dnorm( mu , sigma ) ,
        mu <- a + bFaceMask*face_mask_std + bGermLevel*germ_std + bSanitize*sanitizing_std ,
        a ~ dnorm( 0 , 0.2 ) ,
        bGermLevel ~ dnorm( 0 , 0.5 ) ,
        bFaceMask ~ dnorm( 0 , 0.5 ) ,
        bSanitize ~ dnorm( 0 , 0.5 ) ,
        sigma ~ dexp( 1 )
    ) , data = df )

precis( model1 )

plot(precis( model1 ))


######### MODEL 2 ################
#crn_ _||_ pst_ | grm_
model2<- quap(
    alist(
        corona_fear_std ~ dnorm( mu , sigma ) ,
        mu <- a + bInfected*infected_std  + bGermLevel*germ_std,
        a ~ dnorm( 0 , 0.2 ) ,
        bInfected ~ dnorm( 0 , 1 ) ,
        bGermLevel~ dnorm( 0 , 1 ),
        sigma ~ dexp( 1 )
    ) , data = df )
precis( model2)
plot(coeftab(model2), par=c("bInfected", "bGermLevel" ))

######### MODEL 3 ################
#crn_ _||_ pst_ | fc_m, sntz
model3<- quap(
    alist(
        corona_fear_std ~ dnorm( mu , sigma ) ,
        mu <- a + bInfected * infected_std  + bFaceMask * face_mask_std + bSanitizing * sanitizing_std,
        a ~ dnorm( 0 , 0.2 ) ,
        bInfected ~ dnorm( 0 , 1 ),
        bFaceMask ~ dnorm( 0, 1 ),
        bSanitizing~ dnorm( 0 , 1 ),
        sigma ~ dexp( 1 )
    ) , data = df )

precis( model3)

#plot(coeftab(model3), par=c("bInfected", "bGermLevel", "bSanitizing" ))

plot(precis(model3))


######### MODEL 4 ################
#fc_m _||_ pst_ | grm_
model4<- quap(
    alist(
        face_mask_std ~ dnorm( mu , sigma ) ,
        mu <- a + bInfected*infected_std  + bGermLevel*germ_std,
        a ~ dnorm( 0 , 0.2 ) ,
        bInfected ~ dnorm( 0 , 1 ) ,
        bGermLevel~ dnorm( 0 , 1 ),
        sigma ~ dexp( 1 )
    ) , data = df )
precis( model4)
plot(coeftab(model4), par=c("bInfected", "bGermLevel" ))

######### MODEL 5 ################
#fc_m _||_ sntz | crn_


######### MODEL 6 ################
#pst_ _||_ sntz | grm_
model6<- quap(
    alist(
        infected_std ~ dnorm( mu , sigma ) ,
        mu <- a + bSanitizing*sanitizing_std  + bGermLevel*germ_std,
        a ~ dnorm( 0 , 0.2 ) ,
        bSanitizing ~ dnorm( 0 , 1 ) ,
        bGermLevel~ dnorm( 0 , 1 ),
        sigma ~ dexp( 1 )
    ) , data = df )
precis( model6)

plot(precis(model6))

```


## Task 4: Messing it up

\- Try and **deliberately have an open back door path** and see if you
can get wrong inference.

\- Try and deliberately **simulate some data that doesn't fit the DAG**,
or **create a new DAG that doesn't fit the data**.

\- Use the same approach as above to **show that the DAG is wrong** (by
showing that conditional independencies don't exist in the data, for
example).

## Peter's perfectly optimal and extremely interesting example

*In a galaxy far, far away...*

*It is a period of civil wars in the galaxy. A brave alliance of
underground freedom fighters has challenged the tyranny and oppression
of the awesome GALACTIC EMPIRE.*

*To crush the rebellion once and for all, the EMPIRE is constructing a
sinister new battle station. Powerful enough to destroy an entire
planet, its completion spells certain doom for the champions of
freedom.*

*The evil Emperor has figured out, however, that neither the battle
station nor the Force can help him avoid that more solar systems join
the rebellion. He has therefore hired a CogSci student to use causal
modelling and multiple linear regressions to investigate how the
activity of the Death Star and other factors affects the probability
that a given solar system will join the rebellion (this allows him to
more optimally suppress freedom in the Galaxy).*

*You are that student.*

We assume that the probability of a solar system joining the rebellion
depends on\
- how many rebellion sympathizers there is in the system (more rebels
-\> higher probability of joining the rebellion)\
- how scared people are in the system (more scared -\> lower probability
of joining the rebellion).

How many rebellion sympathizers there is in a system depends on

\- crime levels (less crime -\> less rebellion sympathizers)

\- number of planets recently destroyed by the Death Star (more planets
destroyed -\> more rebellion sympathizers)

\- number of Jedis in the system (more Jedis -\> more rebellion
sympathizers)

How scared people are depends on

\- whether or not the Death Star is nearby (nearby -\> more scared)

\- how many jedis are in the system (more Jedis -\> less scared)

\- how much time Darth Vader has spent in the system recently (more time
-\> more scared)

Crime levels depend on

\- number of planets recently destroyed by the Death Star (more planets
destroyed -\> less crime)

And so on....
